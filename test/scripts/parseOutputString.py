import re
from utils import qol_utils
from mdutils import MdUtils


def dict_to_markdown(data, title="Document", filename="output.md"):
    """
    Converts a dictionary to a markdown document using mdutils.

    Args:
        data: A dictionary containing the content to be formatted.
        title: (Optional) Title of the markdown document.
        filename: (Optional) Filename to save the markdown document to.

    Returns:
        A formatted markdown string or None if writing to a file fails.
    """
    md = MdUtils( title=title)

    for key, value in data.items():
        if isinstance(value, dict):
            # Recursively convert nested dictionaries
            md.new_block(f"## {key}", header_level=2)
            md.new_block(dict_to_markdown(value), indent=4)
        else:
            # Format and add text blocks
            md.new_block(f"**{key}:**", header_level=3)
            md.new_block(f"{value}", indent=4)

    # Save to file if filename provided
    if filename:
        try:
            with open(filename, "w") as f:
                f.write(md.render())
            return None
        except FileNotFoundError:
            print(f"Error saving markdown document to '{filename}'")
            return md.render()

    # Return formatted markdown string
    return md.render()


def parse_function_documentation(documentation_string):
    """
    Parses a function documentation string generated by the mistral-7b-instruct model into a dictionary.

    Args:
        documentation_string (str): The documentation string generated by the model.

    Returns:
        dict: A dictionary containing the parsed function information.

    """
    parsed_data = {}

    # Extract function name
    match = re.search(r"Function Name: (\w+)", documentation_string)
    if match:
        parsed_data["function_name"] = match.group(1)

    # Extract description
    match = re.search(r"Description: (.+)", documentation_string, re.DOTALL)
    if match:
        parsed_data["description"] = match.group(1).strip()

    # Extract arguments
    arguments = []
    for line in documentation_string.splitlines():
        match = re.search(r"- `(\w+)` \((\w+)\): (.+)", line)
        if match:
            arguments.append({
                "name": match.group(1),
                "type": match.group(2),
                "description": match.group(3).strip(),
            })
    if arguments:
        parsed_data["arguments"] = arguments

    # Extract return values
    match = re.search(r"Return Values:\s*(.+)", documentation_string)
    if match:
        parsed_data["return_values"] = match.group(1).strip()

    # Extract explanation (optional)
    explanation = []
    for line in documentation_string.splitlines():
        if line.startswith("Explanation:"):
            explanation.append(line[12:])
    if explanation:
        parsed_data["explanation"] = "\n".join(explanation).strip()

    return parsed_data


# Example usage
documentation_string = """
Function Name: log_directory_structure

Description: This function logs the directory structure by recursively traversing through all subdirectories and files in the given directory path.

Arguments:
- `directory_path` (str): The path of the root directory to be logged. It should exist on the file system.
- `ai_context` (dict): A dictionary containing any additional context information that needs to be passed along with the log messages.
- `indent` (int, optional): An integer specifying how many spaces to indent each level of subdirectories in the output. Default is 0.

Return Values:
None - This function does not return a value.

Explanation:
1. The function first checks if the given directory path exists on the file system using `os.path.exists()` and prints an error message if it doesn't exist.
2. It then gets a list of all items in the directory using `os.listdir()`.
3. For each item, it constructs the full path to that item by joining the directory path with the item name using `os.path.join()` and checks if it's a directory or file using `os.path.isdir()`.
4. If the item is a directory, it logs the directory using the given `ai_context` dictionary and recursively calls itself on that subdirectory with an increased indentation level using `log_directory_structure(item_path, ai_context, indent + 1)`.
5. If the item is a file, it can log it similarly.
6. The function then prompts the user to enter the directory path and logs the root directory with that path.
7. Finally, it calls itself on the given `directory_path` using `log_directory_structure(directory_path, ai_context)`.
"""

parsed_data = parse_function_documentation(documentation_string)
qol_utils.prettyPrintDictionary(parsed_data)

returnedValue = dict_to_markdown(parsed_data)
if returnedValue is None:
    print("Writing failed")
# print(f"Parsed function data: {parsed_data}")