import mdutils


def model_output_to_dict(model_output):
    """
    Converts the string output of a model into a dictionary.

    Args:
        model_output (str): The string output generated by the model.

    Returns:
        dict: A dictionary containing the extracted information from the model output.

    Raises:
        ValueError: If the model output format is not recognized or is incomplete.
    """
    import re

    function_dict = {}

    # Extract function name
    match = re.search(r"^Function Name: (.*?)$", model_output, re.MULTILINE)
    if not match:
        raise ValueError("Function name not found in model output.")
    function_dict["function_name"] = match.group(1).strip()

    # Extract sections and information
    sections = {
        "Description": r"Description:\n(.*?)\n",
        "Arguments": r"Arguments:\n(.*?)\n",
        "Return Values": r"Return Values:\n(.*?)\n",
        "Explanation": r"Explanation:\n(.*?)",
    }
    for section_name, pattern in sections.items():
        match = re.search(pattern, model_output, re.DOTALL)
        if not match:
            raise ValueError(f"Section '{section_name}' not found in model output.")
        function_dict[section_name.lower()] = match.group(1).strip()

    # Extract individual arguments (if applicable)
    if "Arguments" in function_dict:
        argument_list = []
        argument_regex = r"\s*-\s*(.*?):\s*(.*?)(?:\s\(optional\))?"
        for argument_match in re.finditer(argument_regex, function_dict["arguments"]):
            argument_list.append({
                "name": argument_match.group(1).strip(),
                "type": argument_match.group(2).strip(),
                "optional": bool(re.search(r"\(optional\)", argument_match.group(0))),
            })
        function_dict["arguments"] = argument_list

    return function_dict


def list_to_markdown(filename, strings, title=None, ordered=False):
    """
    Writes a list of strings to a markdown file with appropriate formatting.

    Args:
        filename: The path to the markdown file to write to.
        strings: A list of strings to write to the file.
        title (optional): The title for the markdown file (default: None).
        ordered (optional): Whether to format the list as ordered (numbered) or unordered (bullet points) (default: False).

    Returns:
        None
    """
    mdFile = mdutils.MdUtils(filename, title=title)

    # Choose formatting based on ordered flag
    if ordered:
        mdFile.new_list(strings, ul_style=True)
    else:
        mdFile.new_list(strings)

    mdFile.create_md_file()

# Example usage
modelOutput = """
Function Name: log_directory_structure

Description: This function logs the directory structure by recursively traversing through all subdirectories and files in the given directory path.

Arguments:
- `directory_path` (str): The path of the root directory to be logged. It should exist on the file system.
- `ai_context` (dict): A dictionary containing any additional context information that needs to be passed along with the log messages.
- `indent` (int, optional): An integer specifying how many spaces to indent each level of subdirectories in the output. Default is 0.

Return Values:
None - This function does not return a value.

Explanation:
1. The function first checks if the given directory path exists on the file system using `os.path.exists()` and prints an error message if it doesn't exist.
2. It then gets a list of all items in the directory using `os.listdir()`.
3. For each item, it constructs the full path to that item by joining the directory path with the item name using `os.path.join()` and checks if it's a directory or file using `os.path.isdir()`.
4. If the item is a directory, it logs the directory using the given `ai_context` dictionary and recursively calls itself on that subdirectory with an increased indentation level using `log_directory_structure(item_path, ai_context, indent + 1)`.
5. If the item is a file, it can log it similarly.
6. The function then prompts the user to enter the directory path and logs the root directory with that path.
7. Finally, it calls itself on the given `directory_path` using `log_directory_structure(directory_path, ai_context)`.
"""

returnDict = model_output_to_dict(model_output=modelOutput)
print(returnDict)